% Einleitung und evtl. Erklärung von zusätzlichen Themen die für das Verständnis des Design-Patterns sinnvoll, nützlich oder notwendig sind
\chapter{Einleitung}\label{ref:einleitung}
Um die, bereits in der \hyperref[ref:motivation]{Motivation} erwähnten, vielen Abhängigkeiten zwischen den einzelnen Klassen aufzulösen und somit \gls{loose_coupling_g} herzustellen, wird ein Mediator eingesetzt. Wie auch in der Grafik \ref{fig:noMediatorVsMediator} veranschaulicht, interagieren Objekte dann nicht mehr direkt miteinander, sondern immer über den Mediator. Dies führt sowohl zu einigen Vor- als aber auch Nachteilen (siehe: \hyperref[ref:vorteileNachteile]{Vor- und Nachteile vom Mediator}). Weiters gehört der Mediator zur Gruppe der \gls{behavioralpattern_g}.
\cfigure{0.95}{chapters/chapter2_introduction/assets/NoMediatorVsMediator}{Vergleich kein Mediator / Mediator - Extremfall}{noMediatorVsMediator}
\autocite[vgl.][S. 273ff]{gangoffour_book}
%
\section{zusätzlichen Themen}
Um das Mediator Design-Pattern besser verstehen zu können, benötigt es auch das Verständnis folgender Konzepte:
\subsection{lose Kopplung}\label{ref:looseCoupling}
Bei Kopplung im Software-Bereich unterscheidet man meist zwischen starker und loser Kopplung. Als Kopplung wird der Grad der Ab- /bzw. Unabhängigkeit zwischen zwei Komponenten beschrieben. Ziel ist es, möglichst unabhängige Software-Komponenten und somit modulare Software zu erstellen. Die Änderung einer Komponente sollte möglichst keine Auswirkung auf andere haben. Dies hat unter anderem folgende Vorteile: 
\begin{outline}\label{ref:prosLoseKopplung}
    \1 bessere Wartbarkeit: nicht jede kleine Änderung benötigt Änderung am \enquote{gesammten} System. z.B. Datenquelle kann einfach an einer \textbf{einzigen} Stelle ausgetauscht werden und alle funktioniert weiterhin
    \1 Wiederverwendbarkeit: einzelne Komponenten können in neuen Projekten verwendet werden ohne das \enquote{komplette} alte Programm kopieren zu müssen
    \1 Testbarkeit: Während Unit-Test können einzelne Komponenten (oft z.B. Datenbank) gegen emulierte Varianten ausgetauscht werden.
    \1 ...
\end{outline}

\medskip
\noindent\autocite[vgl.][]{loosecoupling_reconceptualization}, basierend auf \autocite[vgl.][S. 101ff]{meilir_loosecoupling}
\medskip

\textbf{Lose Kopplung in Java}: \\
Lose Kopplung in Java (und auch vielen anderen Sprachen) wird oft über Interfaces (bzw. in anderen Sprachen dazu äquivalentes) realisiert. Hier ein simples Beispiel eines Taschenrechners:
\cinputminted{java}{chapters/chapter2_introduction/include/tight.java}{starke Kopplung Beispiel}{tight}
Änderungen in der Calculator-Klassen (ändern der Methoden-Namen / Ändern der Parameter: z.B. Änderung auf Array, damit beliebige Anzahl übergeben werden kann), benötigen in diesem simplen Beispiel zumindest Änderung der CalcularorApp-Klasse oder im schlimmsten Fall sogar bis zur Main-Methode, wenn die CalculatorApp-Klasse nicht als Facade agiert und dann z.B. ebenfalls ein Array erwartet.

Eine bessere Lösung dieser Problemstellung könnte wie folgt aussehen:
\cinputminted{java}{chapters/chapter2_introduction/include/loose.java}{lose Kopplung Beispiel}{loose}

Jedes \enquote{new} sorgt wieder für einen gewissen Grad an starker Kopplung, daher wird das Konzept der Interfaces dann noch mit Dependency-Injection kombiniert, um einen maximal möglichen Grad an Unabhängigkeit zu gewährleisten.
% 
\section{Verwendungsbeispiele aus der Praxis}
\todo{write}
% 
\filbreak
\section{Vor- und Nachteile vom Mediator}\label{ref:vorteileNachteile}
\subsection{Vorteile}
\begin{outline}
    \1 Lose Kopplung: Da der Mediator \gls{loose_coupling_g} fördert, sind die Vorteile dieses (\hyperref[ref:prosLoseKopplung]{Vorteile llose Kopplung}) auch auf den Mediator anwendbar.
        \2 Wartbarkeit: Änderungen in einer Colleague-Klasse benötigt nur Änderung im Mediator. Andere Colleague-Klassen bedürfen keinen Änderungen
        \2 Wiederverwendbarkeit: Colleague und Mediator Klassen können unabhängig wiederverwendet / ausgetauscht werden
        \2 Testbarkeit: Es kann einfach eine andere Implementierung des Mediator-Interfaces verwendet werden.
    \1 Änderbarkeit / Erweiterbarkeit: Anderes Verhalten bzw. weitere Funktionen benötigt nur Änderung / erstellen einer Sub-Klasse bzw. Implementierung des Interfaces des Mediators. Colleague-Klassen können oft 1 zu 1 wiederverwendet werden,
    \1 zentrale Stelle zur Verwaltung der Interaktions-Logik zwischen den Objekten. Auch sind dadurch die komplexität der Colleague Objekte selbst,
        \2 bessere Übersicht / Lesbarkeit / Verständnis,
        \2 bessere Wartbarkeit,
        \2 vereinfachte Interaktionslogik: vorher Many-To-Many Beziehungen zwischen Colleagues - jetzt nur mehr One-To-One/Many: Colleague -(one)> Mediator -(many)> anderer Colleague
    \1 ...
\end{outline}

\subsection{Nachteile}
\begin{outline}
    \1 Auslagerung der Komplexität der Interaktion zwischen Objekten in Mediator lässt diese nicht magisch verschwinden. Oft wird der Mediator selbst dann sehr komplex → wird zum Monolith, ohne den nichts geht → wieder nicht gut für Wiederverwendbarkeit
    \1 \enquote{god object}: im Worstcase wird der Mediator zu einem oft als \enquote{God Object} bezeichneten Objekt. Also einem Objekt, dass alles kann / macht. Eine Klasse mit \textbf{allen (tausenden) Funktionen} der Applikation.
    \1 geringere Flexibilität: Interaktion muss / sollte immer über Mediator passieren
    \1 Mediator verletzt 1. SOLID Design Prinzip (Single-responsibility): gibt meist deutlich mehr als einen Grund den Mediator zu ändern / hat mehr als 1 Aufgabe
    \1 Skalierbarkeit: Mediator kann zum Bottleneck werden
    \1 einige kleinere (\enquote{unwichtige}) Nachteile:
        \2 KISS-Prinzip / Overengineering: für kleine Applikationen erhöht der Mediator (wie auch andere Design-Patterns) nur Sinnlos den Aufwand der Entwicklung. Es bedarf hier generell immer einer Abwägung: Ja, Design-Patterns sind wichtig und sinnvoll, aber man kann es auch übertreiben
        \2 (zusätzliches Objekt -> \enquote{höherer} Ressourcenbedarf)
    \1 ...
\end{outline}

\autocite[vgl.][S. 273ff]{gangoffour_book} + eigene Ergänzungen
% 
\section{Verwandte Design-Patterns}
Der Mediator ähnelt dem Facade-Pattern. Allerdings unterscheidet er sich wie folgt: Einen Mediator kann man sich ein bisschen wie eine BI-direktionale-Fassade vorstellen. Eine Facade stellt z.B. eine einfachere Schnittstelle für eine komplexe Library bereit. Ein Mediator vereinfacht die Kommunikation \textbf{zwischen} (also in beide Richtungen!) zwei Objekten. Zusätzlich kann ein Mediator zusätzliche Funktionalität bereitstellen, die von den einzelnen Colleague Objekten selbst nicht bereitgestellt wird / bereitgestellt werden kann. 
\autocite[vgl.][S. 273ff]{gangoffour_book}